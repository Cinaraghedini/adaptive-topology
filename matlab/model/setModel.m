
% testbed and model parametrization setting

param.networkSize = 20;  %number of nodes
param.numberNetworks=10; %number of networks with sequencial id (number), param.networkList=[] 
param.networkList=[]; %for specific network list the network id(number) e.g. [1 3 7]
param.area = 50; % arena x and y sizes in meters,  area=param.area^2.  
param.lowerB = 1; % arena lower bound 
param.upperB = param.area; % arena upper bound


% parameters for network properties estimation

param.range = 16; % node's communication range
param.nrProp=9; % number of network properties evaluated - for plot control
param.nrPropCoverage=17; % number of network properties evaluated - for plot control
param.save=1; % 1 for saving properties at each iteration inside ODE
param.connected = 1; % if a connected graph is required
param.network=0; % for the code control, do not set it.
param.algebraic = 1; % if the algebraic threshold need to be fulfilled
param.normalized=0; %algebraic connectivity normalized 

% general model parametrization

param.t0=0; %initial time
param.ti=1; % time step
param.tf=80; %final time
param.option=odeset('Abstol',1e-5,'Reltol',1e-5,'Jacobian','on'); %ODE boundaries set
param.iteration=round(param.tf/param.ti); %number of iteration
param.tol=1e-5; % used for rounding float and avoid problems in comparison methods

% robustness model

param.nrPaths = 2; % number of redundant paths a node should have to its 2-hop neighbors in order to be not vulnerable
param.k=0.1;  % linear velocity
param.theta=1; % if 1, a random number is generated to define the vulnerability threshold, if < 1 its value defines the vulnerability threshold 
param.gainRobustnessControl=1; % robustness control law gain 


%Algebraic Connectivity

param.threshold = .2; %algegraic connectivity control law parameter
param.epsilon = .2; % epsilon 
param.sigma = sqrt((-param.range^2)/(2*log(param.threshold))); % algebraic connectivity control law parameter
param.gainConnectivity=1; %algegraic connectivity control law gain
param.adpGain=0; %using during the adaptive process - if the network disconnectes because failures, the param.gainConnectivity is set as 0, for avoiding singularity

%not used so far because global quantities are considered to the experiment
param.px=[];
param.py=[];
param.v2=[];
param.lambda=[];

%collision avoidance model

param.collisonAvoidance=1; % 1; %if collision avoidance is active or not - for controlling the obstacles generation
param.gainCollisionAvoidance=1; %collision avoidance control law gain
param.obstacleN = 50; %number of obstacles 
param.minDistObstacle=2; %minimal distance in meters

% coverage area model

param.gainCoverageController=1; %coverage control law gain

param.nrPoints=50; % number of spots to be considered to evaluate the area covered by robots


% inputing a constant gain for allowing agents to move foward

param.constantFormationX=5; % velocity x dimension
param.constantFormationY=0; % velocity y dimension
param.gainFormationX=1; % formation gain for x (cartesian plane)
param.gainFormationY=1; % formation gain for y (cartesian plane)


%saturation - not necessary to use, so far

param.lowerSat=-5;
param.upperSat=5;


% for an integrated simulation
     
param.gain=[0 0 0; 2 0 1;2 1 0;2 1 1]; %gains definition for \sigma (algebraic connectivity), \psi (robustness), '\zeta' (coverage)

param.labels=[]; %for figures labels and legends
for i=1:size(param.gain,1)
    param.labels=[param.labels {['\sigma=' num2str(param.gain(i,1)) ',\psi=' num2str(param.gain(i,2)) ',\zeta='  num2str(param.gain(i,3))]}];
end
     
param.legend=[]; % legend generated by the simulation
param.XTickLabel=[]; % generated during the simulation


% failure model parameters

param.attack=0; %if nodes will be removed from the network

param.fractionIteration=1; % 1 if is one node, < 1 if it is a fraction of the network node at each iteration
param.fractionFailures=0.7; % the fraction of nodes to be failures during the simulation 
param.nrFailures=param.fractionFailures*param.networkSize; %number of nodes to be removed from the network
param.listNodeFailure=[]; % nodes to fail - generateb by a process at the begining of the execution
param.index = [{'BC'} {'Random'}];  % Define the kind of attack 'BC' - Betweeness, 'DC'- Degree and 'Random' 

%label settings

param.indexDsc = [{'BC-Attacks'}  {'Random'}];
param.failureOp = 'BC';  % type of failure

if param.attack
    param.labelX='f';
else
    param.labelX='t';
end

param.lowerX= param.area + 5; % boundaries area for agent and obstacles placements
param.upperX= param.area * 10; % boundaries area for agent and obstacles placements
param.lowerY= param.lowerB; % boundaries area for agent and obstacles placements
param.upperY= param.upperB;% boundaries area for agent and obstacles placements

%persistence Information - you need to setup the path from where the database will be upload

param.path = ['Z:\Project_ITA_Unimore\database\' num2str(param.networkSize) '\' strcat(num2str(param.area),'_',strcat(num2str(param.range))) '\'];

%persistence Information - you need to setup the path where the experiment results will be saved

param.mainPath = ['Z:\Project_ITA_Unimore\results\fault-free\' num2str(param.networkSize) '\' ] ;
%param.mainPath = ['Z:\Project_ITA_Unimore\results\fault-prone\' num2str(param.networkSize) '\' ] ;

param.fileId='iterationData'; % reference string for composing file names.