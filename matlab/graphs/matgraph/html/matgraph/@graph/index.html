<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN"
                "http://www.w3.org/TR/REC-html40/loose.dtd">
<html>
<head>
  <title>Index for Directory matgraph/@graph</title>
  <meta name="keywords" content="matgraph/@graph">
  <meta name="description" content="Index for Directory matgraph/@graph">
  <meta http-equiv="Content-Type" content="text/html; charset=iso-8859-1">
  <meta name="generator" content="m2html &copy; 2003 Guillaume Flandin">
  <meta name="robots" content="index, follow">
  <link type="text/css" rel="stylesheet" href="../../m2html.css">
</head>
<body>
<a name="_top"></a>
<table width="100%"><tr><td align="left"><a href="../../index.html"><img alt="<" border="0" src="../../left.png">&nbsp;Master index</a></td>
<td align="right"><a href="index.html">Index for matgraph/@graph&nbsp;<img alt=">" border="0" src="../../right.png"></a></td></tr></table>

<h1>Index for matgraph/@graph</h1>

<h2>Matlab files in this directory:</h2>
<table>
<tr><td><img src="../../matlabicon.gif" alt="" border="">&nbsp;<a href="across.html">across</a></td><td>across(g,X,Y) --- find all edges with one end in X and other end in Y. </td></tr><tr><td><img src="../../matlabicon.gif" alt="" border="">&nbsp;<a href="add.html">add</a></td><td>add --- add edge(s) to the graph </td></tr><tr><td><img src="../../matlabicon.gif" alt="" border="">&nbsp;<a href="alpha.html">alpha</a></td><td>[a,S] = alpha(g) --- indepencence number </td></tr><tr><td><img src="../../matlabicon.gif" alt="" border="">&nbsp;<a href="bfstree.html">bfstree</a></td><td>bfstree(t,g,v) --- create a breadth-first spanning tree of g </td></tr><tr><td><img src="../../matlabicon.gif" alt="" border="">&nbsp;<a href="bipartition.html">bipartition</a></td><td>part = bipartition(g) --- find bipartition of a bipartite graph </td></tr><tr><td><img src="../../matlabicon.gif" alt="" border="">&nbsp;<a href="bipmatch.html">bipmatch</a></td><td>bipmatch --- maximum matching in a bipartite graph </td></tr><tr><td><img src="../../matlabicon.gif" alt="" border="">&nbsp;<a href="bucky.html">bucky</a></td><td>bucky(g) --- overwrite g with the Buckyball graph (and give a nice </td></tr><tr><td><img src="../../matlabicon.gif" alt="" border="">&nbsp;<a href="cartesian.html">cartesian</a></td><td>cartesian(g,h1,h2) --- overwrite g with the product of h1 and h2 </td></tr><tr><td><img src="../../matlabicon.gif" alt="" border="">&nbsp;<a href="cdraw.html">cdraw</a></td><td>cdraw(g,coloring) -- draw g with a given vertex coloring </td></tr><tr><td><img src="../../matlabicon.gif" alt="" border="">&nbsp;<a href="chromatic_poly.html">chromatic_poly</a></td><td>chromatic_poly(g) --- find the chromatic polynomial of g </td></tr><tr><td><img src="../../matlabicon.gif" alt="" border="">&nbsp;<a href="circulant.html">circulant</a></td><td>circulant(g,n,k) --- overwrite g with an n,k circulant graph </td></tr><tr><td><img src="../../matlabicon.gif" alt="" border="">&nbsp;<a href="clear_edges.html">clear_edges</a></td><td>clear_edges(g) --- delete all edges of g </td></tr><tr><td><img src="../../matlabicon.gif" alt="" border="">&nbsp;<a href="clear_labels.html">clear_labels</a></td><td>clearl_labels(g) --- delete all labels in g </td></tr><tr><td><img src="../../matlabicon.gif" alt="" border="">&nbsp;<a href="color.html">color</a></td><td>color(g,algo) --- color the graph g by a given algorithm </td></tr><tr><td><img src="../../matlabicon.gif" alt="" border="">&nbsp;<a href="complement.html">complement</a></td><td>graph complement </td></tr><tr><td><img src="../../matlabicon.gif" alt="" border="">&nbsp;<a href="complete.html">complete</a></td><td>complete: build complete and complete multipartite graphs </td></tr><tr><td><img src="../../matlabicon.gif" alt="" border="">&nbsp;<a href="component.html">component</a></td><td>component(g,v) -- find vertices in v's component of g </td></tr><tr><td><img src="../../matlabicon.gif" alt="" border="">&nbsp;<a href="components.html">components</a></td><td>components(g) --- find the components of the graph g </td></tr><tr><td><img src="../../matlabicon.gif" alt="" border="">&nbsp;<a href="contract.html">contract</a></td><td>contract(g,u,v) --- contract v into u </td></tr><tr><td><img src="../../matlabicon.gif" alt="" border="">&nbsp;<a href="copy.html">copy</a></td><td>copy(g,h) --- overwrite g with a copy of h </td></tr><tr><td><img src="../../matlabicon.gif" alt="" border="">&nbsp;<a href="copy_labels.html">copy_labels</a></td><td>copy_labels(g,h) --- copy labels from h to g </td></tr><tr><td><img src="../../matlabicon.gif" alt="" border="">&nbsp;<a href="cube.html">cube</a></td><td>cube(g,k) --- create a k-cube (default k = 3) </td></tr><tr><td><img src="../../matlabicon.gif" alt="" border="">&nbsp;<a href="cycle.html">cycle</a></td><td>cycle(g,n) --- create a cycle graph on n vertices </td></tr><tr><td><img src="../../matlabicon.gif" alt="" border="">&nbsp;<a href="deg.html">deg</a></td><td>deg: degree of a vertex or degree sequence </td></tr><tr><td><img src="../../matlabicon.gif" alt="" border="">&nbsp;<a href="delete.html">delete</a></td><td>delete --- delete vertices or edges from a graph </td></tr><tr><td><img src="../../matlabicon.gif" alt="" border="">&nbsp;<a href="dfstree.html">dfstree</a></td><td>dfstree(t,g,v) --- create a depth-first spanning tree of g </td></tr><tr><td><img src="../../matlabicon.gif" alt="" border="">&nbsp;<a href="diam.html">diam</a></td><td>diam(g) --- return the diameter of g: the length of a longest shortest </td></tr><tr><td><img src="../../matlabicon.gif" alt="" border="">&nbsp;<a href="disjoint_union.html">disjoint_union</a></td><td>disjoint_union(g,h,k) --- overwrite g with the disjoint union of the </td></tr><tr><td><img src="../../matlabicon.gif" alt="" border="">&nbsp;<a href="display.html">display</a></td><td>display(g) --- display basic information about a graph object </td></tr><tr><td><img src="../../matlabicon.gif" alt="" border="">&nbsp;<a href="dist.html">dist</a></td><td>dist(g,v,w) and dist(g,v) --- find distance(s) between vertices </td></tr><tr><td><img src="../../matlabicon.gif" alt="" border="">&nbsp;<a href="distxy.html">distxy</a></td><td>distxy(g) -- give g a distance based embedding </td></tr><tr><td><img src="../../matlabicon.gif" alt="" border="">&nbsp;<a href="dodecahedron.html">dodecahedron</a></td><td>dodecahedron(g) --- overwrite g with the dodecahedron graph </td></tr><tr><td><img src="../../matlabicon.gif" alt="" border="">&nbsp;<a href="dom.html">dom</a></td><td>[d,S] = dom(g) --- domination number of g </td></tr><tr><td><img src="../../matlabicon.gif" alt="" border="">&nbsp;<a href="dot.html">dot</a></td><td>dot(g,filename) --- save graph for use by graphviz. </td></tr><tr><td><img src="../../matlabicon.gif" alt="" border="">&nbsp;<a href="draw.html">draw</a></td><td>draw(g) --- draw g in a figure window </td></tr><tr><td><img src="../../matlabicon.gif" alt="" border="">&nbsp;<a href="edges.html">edges</a></td><td>edges(g) --- list the edges in g as a 2-column matrix </td></tr><tr><td><img src="../../matlabicon.gif" alt="" border="">&nbsp;<a href="embed.html">embed</a></td><td>embed --- create an embedding for a graph </td></tr><tr><td><img src="../../matlabicon.gif" alt="" border="">&nbsp;<a href="eq.html">eq</a></td><td>yn = eq(g,h) --- check if two graphs are equal (identical) </td></tr><tr><td><img src="../../matlabicon.gif" alt="" border="">&nbsp;<a href="euler_trail.html">euler_trail</a></td><td>euler_trail(g) --- find an euler trail in g (if one exists) </td></tr><tr><td><img src="../../matlabicon.gif" alt="" border="">&nbsp;<a href="fast_set_matrix.html">fast_set_matrix</a></td><td>fast_set_matrix(g,A) --- overwrite the adjacency matrix of g with A </td></tr><tr><td><img src="../../matlabicon.gif" alt="" border="">&nbsp;<a href="find_path.html">find_path</a></td><td>find_path(g,u,v) --- find a shortest path from u to v </td></tr><tr><td><img src="../../matlabicon.gif" alt="" border="">&nbsp;<a href="free.html">free</a></td><td>free(g) --- free the graph from the system </td></tr><tr><td><img src="../../matlabicon.gif" alt="" border="">&nbsp;<a href="full.html">full</a></td><td>full(g) --- convert internal storage for g to full </td></tr><tr><td><img src="../../matlabicon.gif" alt="" border="">&nbsp;<a href="get_label.html">get_label</a></td><td>get_label(g) or get_label(g,v) --- get vertex label(s) </td></tr><tr><td><img src="../../matlabicon.gif" alt="" border="">&nbsp;<a href="getxy.html">getxy</a></td><td>getxy(g) --- give g's embedding (or [] if g doesn't have one) </td></tr><tr><td><img src="../../matlabicon.gif" alt="" border="">&nbsp;<a href="graffle.html">graffle</a></td><td>graffle(g, filename, width, rad) --- write graph in OmniGraffle format </td></tr><tr><td><img src="../../matlabicon.gif" alt="" border="">&nbsp;<a href="graph.html">graph</a></td><td>graph: constructor for the graph class </td></tr><tr><td><img src="../../matlabicon.gif" alt="" border="">&nbsp;<a href="grid.html">grid</a></td><td>grid(g,a,b) --- create an a-by-b grid graph </td></tr><tr><td><img src="../../matlabicon.gif" alt="" border="">&nbsp;<a href="hamiltonian_cycle.html">hamiltonian_cycle</a></td><td>hamiltonian_cycle(g) --- find a Hamiltonian cycle in g (if one exists) </td></tr><tr><td><img src="../../matlabicon.gif" alt="" border="">&nbsp;<a href="has.html">has</a></td><td>has --- check if the graph has a particular vertex or edge </td></tr><tr><td><img src="../../matlabicon.gif" alt="" border="">&nbsp;<a href="has_path.html">has_path</a></td><td>has_path(g,u,v) --- determine if there is a path from u to v in g </td></tr><tr><td><img src="../../matlabicon.gif" alt="" border="">&nbsp;<a href="hasxy.html">hasxy</a></td><td>hasxy(g) --- determine if an embedding has been created for g </td></tr><tr><td><img src="../../matlabicon.gif" alt="" border="">&nbsp;<a href="icosahedron.html">icosahedron</a></td><td>icosahedron(g) --- overwrite g with the icosahedron graph </td></tr><tr><td><img src="../../matlabicon.gif" alt="" border="">&nbsp;<a href="incidence_matrix.html">incidence_matrix</a></td><td>incidence_matrix(g) --- return the vertex/edge incidence matrix. </td></tr><tr><td><img src="../../matlabicon.gif" alt="" border="">&nbsp;<a href="induce.html">induce</a></td><td>induce --- create induced subgraphs </td></tr><tr><td><img src="../../matlabicon.gif" alt="" border="">&nbsp;<a href="intersect.html">intersect</a></td><td>intersect(g,h1,h2) --- g is set to the intersection of h1 and h2. </td></tr><tr><td><img src="../../matlabicon.gif" alt="" border="">&nbsp;<a href="interval_graph.html">interval_graph</a></td><td>interval_graph(g,ilist) --- create an interval graph </td></tr><tr><td><img src="../../matlabicon.gif" alt="" border="">&nbsp;<a href="is_labeled.html">is_labeled</a></td><td>is_labeled(g) --- determine if there are labels on vertices. </td></tr><tr><td><img src="../../matlabicon.gif" alt="" border="">&nbsp;<a href="isconnected.html">isconnected</a></td><td>isconnected(g) --- test if g is a connected graph </td></tr><tr><td><img src="../../matlabicon.gif" alt="" border="">&nbsp;<a href="isfull.html">isfull</a></td><td>isfull(g) --- check if g's adjacency matrix is full </td></tr><tr><td><img src="../../matlabicon.gif" alt="" border="">&nbsp;<a href="iso.html">iso</a></td><td>[yn,p] = iso(g,h) --- is g isomorphic to h? </td></tr><tr><td><img src="../../matlabicon.gif" alt="" border="">&nbsp;<a href="issparse.html">issparse</a></td><td>issparse(g) --- check if g's adjacency matrix is sparse </td></tr><tr><td><img src="../../matlabicon.gif" alt="" border="">&nbsp;<a href="join.html">join</a></td><td>join(g,h1,h2) --- overwrite g with the join of h1 and h2 </td></tr><tr><td><img src="../../matlabicon.gif" alt="" border="">&nbsp;<a href="label.html">label</a></td><td>Assign labels to vertices of g </td></tr><tr><td><img src="../../matlabicon.gif" alt="" border="">&nbsp;<a href="laplacian.html">laplacian</a></td><td>laplacian(g) --- get the Laplacian matrix of g </td></tr><tr><td><img src="../../matlabicon.gif" alt="" border="">&nbsp;<a href="ldraw.html">ldraw</a></td><td>ldraw(g,line_style) --- draw a graph with vertices marked with their labels </td></tr><tr><td><img src="../../matlabicon.gif" alt="" border="">&nbsp;<a href="line_graph.html">line_graph</a></td><td>line_graph(g,h) --- set g to be the line graph of h </td></tr><tr><td><img src="../../matlabicon.gif" alt="" border="">&nbsp;<a href="load.html">load</a></td><td>load(g,filename) --- read a saved graph on disk </td></tr><tr><td><img src="../../matlabicon.gif" alt="" border="">&nbsp;<a href="make_logical.html">make_logical</a></td><td>make_logical(g) --- ensure that the internal storage for g's matrix is a </td></tr><tr><td><img src="../../matlabicon.gif" alt="" border="">&nbsp;<a href="match_join.html">match_join</a></td><td>match_join(g,h1,h2) --- overwrite g with a graph formed from disjoint </td></tr><tr><td><img src="../../matlabicon.gif" alt="" border="">&nbsp;<a href="matrix.html">matrix</a></td><td>matrix(g) --- return (a copy of) the adjacency matrix of g </td></tr><tr><td><img src="../../matlabicon.gif" alt="" border="">&nbsp;<a href="mycielski.html">mycielski</a></td><td>mycielski(g,n) --- create n'th order Mycielski graph (n > 0) </td></tr><tr><td><img src="../../matlabicon.gif" alt="" border="">&nbsp;<a href="ndraw.html">ndraw</a></td><td>ndraw(g) --- draw g in a figure window with numbered vertices </td></tr><tr><td><img src="../../matlabicon.gif" alt="" border="">&nbsp;<a href="ne.html">ne</a></td><td>ne(g) --- number of edges in g or ne(g,h) --- check for inequality </td></tr><tr><td><img src="../../matlabicon.gif" alt="" border="">&nbsp;<a href="neighbors.html">neighbors</a></td><td>neighbors(g,v) --- neighbors of v as a list. </td></tr><tr><td><img src="../../matlabicon.gif" alt="" border="">&nbsp;<a href="nsptrees.html">nsptrees</a></td><td>nsptrees(g) --- number of spanning trees of g. </td></tr><tr><td><img src="../../matlabicon.gif" alt="" border="">&nbsp;<a href="nv.html">nv</a></td><td>nv(g) --- number of vertices in g </td></tr><tr><td><img src="../../matlabicon.gif" alt="" border="">&nbsp;<a href="octahedron.html">octahedron</a></td><td>octahedron(g) --- overwrite g with the octahedron graph, K(2,2,2) </td></tr><tr><td><img src="../../matlabicon.gif" alt="" border="">&nbsp;<a href="omega.html">omega</a></td><td>[w,S] = omega(g) --- clique number </td></tr><tr><td><img src="../../matlabicon.gif" alt="" border="">&nbsp;<a href="paley.html">paley</a></td><td>paley(g,n) --- create a Paley graph with n vertices </td></tr><tr><td><img src="../../matlabicon.gif" alt="" border="">&nbsp;<a href="path.html">path</a></td><td>path(g,n) --- make g a path on n vertices </td></tr><tr><td><img src="../../matlabicon.gif" alt="" border="">&nbsp;<a href="petersen.html">petersen</a></td><td>petersen(g) --- overwrite g with the Petersen graph </td></tr><tr><td><img src="../../matlabicon.gif" alt="" border="">&nbsp;<a href="prufer.html">prufer</a></td><td>prufer --- convert a tree to/from its Prufer code </td></tr><tr><td><img src="../../matlabicon.gif" alt="" border="">&nbsp;<a href="random.html">random</a></td><td>random --- overwrite g with a random graph </td></tr><tr><td><img src="../../matlabicon.gif" alt="" border="">&nbsp;<a href="random_bipartite.html">random_bipartite</a></td><td>random_bipartite(g,n,m,p) --- create a random bipartite graph </td></tr><tr><td><img src="../../matlabicon.gif" alt="" border="">&nbsp;<a href="random_regular.html">random_regular</a></td><td>random_regular(g,n,k) --- create a random regular graph </td></tr><tr><td><img src="../../matlabicon.gif" alt="" border="">&nbsp;<a href="random_tree.html">random_tree</a></td><td>random_tree(t,n) --- overwrite t with a random tree on n vertices </td></tr><tr><td><img src="../../matlabicon.gif" alt="" border="">&nbsp;<a href="randxy.html">randxy</a></td><td>randxy(g) --- give g a random embedding in the plane </td></tr><tr><td><img src="../../matlabicon.gif" alt="" border="">&nbsp;<a href="renumber.html">renumber</a></td><td>renumber the vertices of a graph </td></tr><tr><td><img src="../../matlabicon.gif" alt="" border="">&nbsp;<a href="resize.html">resize</a></td><td>resize(g,n) --- change the number of vertices in g to n </td></tr><tr><td><img src="../../matlabicon.gif" alt="" border="">&nbsp;<a href="rmxy.html">rmxy</a></td><td>rmxy(g) --- erase g's embedding </td></tr><tr><td><img src="../../matlabicon.gif" alt="" border="">&nbsp;<a href="save.html">save</a></td><td>save(g,filename) --- save a graph to disk </td></tr><tr><td><img src="../../matlabicon.gif" alt="" border="">&nbsp;<a href="scale.html">scale</a></td><td>scale(g,s) --- rescale the embedding of g by s </td></tr><tr><td><img src="../../matlabicon.gif" alt="" border="">&nbsp;<a href="set_matrix.html">set_matrix</a></td><td>set_matrix(g,A) --- set g to be the graph specificed in the matrix A. </td></tr><tr><td><img src="../../matlabicon.gif" alt="" border="">&nbsp;<a href="sgf.html">sgf</a></td><td>sgf --- simple graph format: a 2-column matrix representation </td></tr><tr><td><img src="../../matlabicon.gif" alt="" border="">&nbsp;<a href="size.html">size</a></td><td>size(g) --- returns [nv,ne] for the graph </td></tr><tr><td><img src="../../matlabicon.gif" alt="" border="">&nbsp;<a href="slot.html">slot</a></td><td>slot(g) --- slot number occupied by g in GRAPH_MAGIC </td></tr><tr><td><img src="../../matlabicon.gif" alt="" border="">&nbsp;<a href="sparse.html">sparse</a></td><td>sparse(g) --- convert internal storage for g to sparse </td></tr><tr><td><img src="../../matlabicon.gif" alt="" border="">&nbsp;<a href="split.html">split</a></td><td>part = split(g) --- partition the vertices of g into two subsets </td></tr><tr><td><img src="../../matlabicon.gif" alt="" border="">&nbsp;<a href="sprandom.html">sprandom</a></td><td>sprandom(g,n,p) --- create a sparse random graph </td></tr><tr><td><img src="../../matlabicon.gif" alt="" border="">&nbsp;<a href="springxy.html">springxy</a></td><td>springxy(g) --- find a spring embedding of g </td></tr><tr><td><img src="../../matlabicon.gif" alt="" border="">&nbsp;<a href="spy.html">spy</a></td><td>spy(g) --- display the "spy" of g's adjacency matrix </td></tr><tr><td><img src="../../matlabicon.gif" alt="" border="">&nbsp;<a href="subsref.html">subsref</a></td><td>subsref implements the notation g(v) and g(v,w) </td></tr><tr><td><img src="../../matlabicon.gif" alt="" border="">&nbsp;<a href="trim.html">trim</a></td><td>trim(g,d) --- iteratively remove vertices of degree at most d </td></tr><tr><td><img src="../../matlabicon.gif" alt="" border="">&nbsp;<a href="union.html">union</a></td><td>union(g,h1,h2) --- set g equal to the union of h1 and h2. </td></tr><tr><td><img src="../../matlabicon.gif" alt="" border="">&nbsp;<a href="wheel.html">wheel</a></td><td>wheel(g,n) --- overwrite g with a wheel graph on n vertices </td></tr></table>


<h2>Subsequent directories:</h2>
<ul style="list-style-image:url(../../matlabicon.gif)">
<li>old-versions</li><li>private</li></ul>

<hr><address>Generated on Wed 11-Oct-2006 09:58:30 by <strong><a href="http://www.artefact.tk/software/matlab/m2html/">m2html</a></strong> &copy; 2003</address>
</body>
</html>