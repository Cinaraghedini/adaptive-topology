% filename: boundedVoronoi.m
% Purpose:  generates a bounded voronoi diagram for a set of generating
% points
% Input:
% - position - matrix with x and y coordinates for each network agent that
% is used as a generating points 
% - param - parametrization struct
% Output:
% a cell with size (1,N), where N is the number of generating points, for 10 generating points, size(newC)=[19,1]. 
% Each cell contains the vertices of the voronoi diagram for that
% generating point. Each reference of is the vertices v1 and v2 of an edge/line of the voronoi diagram. 
% newC{1,1}(1,1) x coordinate of the first vertex, 
% newC{1,1}(1,2) y coordinate of the first vertex,  
% newC{1,1}(1,3) x coordinate of the second vertex
% newC{1,1}(1,4) y coordinate of the secibd vertex.  
% For instance, for a generating point at position 1, the cell newC{1,1} value could be
%[40.5222100000000 21.8298400000000 48.9117212446816 33.3808245383955;
%[48.9117212446816 33.3808245383955 49.7571950834606 32.9634015430354;
%49.7571950834606 32.9634015430354 53.4080874894826 30.0117809149336;
%43.8129000000000 18.2939200000000 53.9316250359134 29.3559535964416;
%53.9316250359134 29.3559535964416 53.4080874894826 30.0117809149336;
%43.8129000000000 18.2939200000000 40.5222100000000 21.8298400000000]
% Notice that taking each edge in sequence can generate a polygon.
% - Reference :Erik Tjong Kim Sang. Voronoi diagrams without bounding boxes. In ISPRS Annals of the Photogrammetry, 
% Remote Sensing and Spatial Information Sciences, II-2/W2, 2015.


function [newC] = boundedVoronoi(position,param)


[V C] = pointVoronoiCell(position,param); % generating a voronoi diagram without vertices pointing to infinite 

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
% Defining cutting points for unbounded cells with one vertice inside the
% circle and another outside
% Defining edges lying inside the cell.

newC=cell(size(C,1),1);

for j=1:size(C,1)
    center=position(j,:); % defines the generating point (node) as the center of a circle
    xypoint=C{j,1}; % cell containing the references for vertices in node j cell
    newPoints=[];
    for jj=1:size(xypoint,1) % for each vertice into node j voronoi cell
        v1=V(xypoint(jj,1),:); 
        v2=V(xypoint(jj,2),:);
        boundingSet = verify_boundingCircle(v1,v2,center,(param.range*0.8)); % array setting vertices as inside or outside the circle based on j position
        outSidePoint=find(boundingSet==-1);
        if isempty(outSidePoint) % if all the vertices are inside the circle having j as center no further preprocessing is necessary
            newPoints=[newPoints; v1 v2] ;
        else
            if (length(outSidePoint)==1) % if one point is outside the circle
                insideP=find(boundingSet==1); % finds inside vertice
                posboundingInside=xypoint(jj, insideP); 
                insideV=V(posboundingInside,:); % contains the vertices inside node j circle
                [xl, yl]=compute_x(v1,v2,center(1,1),center(1,2),(param.range*0.8)); % finds x and y roots
                posboundingOutside=xypoint(jj,outSidePoint);
                outsideV=V(posboundingOutside,:);
                [xy] = findIntersectionPoint([xl yl],outsideV); % finds intersection point  of line given by vertices v1 and v2 and the circle generated by center
                newPoints=[newPoints; insideV xy]; % intersection point is now replacing the outside vertice
                distancei_ii=pdist([outsideV; center],'euclidean');
                pointsCurve_Center= center+((outsideV-center)*(param.range*0.8))/distancei_ii;
                newPoints=[newPoints; xy pointsCurve_Center]; % a point into the circle curve is defined as a new vertice that is connected to the intersection point 
            else
                %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
                % Creating new curve points for unbonded cells with both vertices outside
                % the range according to reference 
                distanceP_center=pdist([v1; center],'euclidean');
                newPointV1 = [center+((v1-center)*(param.range*0.8))/distanceP_center];
                distanceP_center=pdist([v2; center],'euclidean');
                newPointV2 = [center+((v2-center)*(param.range*0.8))/distanceP_center];
                newPoints=[newPoints; newPointV1 newPointV2];
            end
        end
        
    end

    newC(j,1)={newPoints};

end