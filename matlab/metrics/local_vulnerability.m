% filename: local_vulnerability.m
% Purpose:  estimating the vulnerability level for each network node and its most weak connections for definition of the target goal position
% Input: 
% - position - x and y coordinates for each network agent
% - param - parametrization struct
% Output: 
% - vN - struct containing for each vulnerable node its 2-hop neighbor with at most param.nrPaths and their position 

function vN=local_vulnerability(position,param)

[data] = create_Ninf(position,param); % struct for supporting vulnerability estimation

vN=[];
dds=[];
for i=1:size(data,1)

    node=data{i,1}{1,1};
     
    nNeighbors=size(data{i,1}{1,3},2); % list of neighbors
    
    if nNeighbors > 0
    
        dds=[];
        
        for j=2:nNeighbors+1  % find bridges  - nodes that are at 1-hop and connecting to 2-hop neighbors
           nodeBridge=[];
           nodeBridge(1:size(data{i,1}{j,3}),1)=data{i,1}{j,1};
           dds=[dds; [ cell2mat(data{i,1}(j,1:2)) data{i,1}{j,1}]; [data{i,1}{j,3} nodeBridge]]; 
        end
            
    end
    
    countNodes=[];
    if ~isempty(dds)
        
        idNodes=transpose(unique(dds(:,1)));
        
        vulnerable=[];
        
        for j=idNodes
            if isempty(find(data{i,1}{1,3}==j)) && j~=node % 2-hop neighbor
                nodesPath=find(dds(:,1)==j); % find commom 2-hop neighbor
                if size(nodesPath,1) < param.nrPaths % if the 2-hop neighbor is connected to node by less than param.nrPaths paths 
                    for k=1:size(nodesPath,1)
                        vulnerable = [vulnerable; dds(nodesPath(k),:)]; 
                    end                    
                end
            end
        end
        
        if ~isempty(vulnerable) % there is vulnerable nodes
            reach=size(idNodes,2); % number of nodes into the node neighborhood
            countVulnerable=size(vulnerable,1); % computes the number of 2-hop neighbors with vulnerable state
            if param.theta==1 % random number
                vulnerability_threshold=rand; %generates a random [0 1] number for vulnerabilty threshold
            else
                vulnerability_threshold=param.theta;
            end
            if vulnerability_threshold <= countVulnerable/reach || nNeighbors==1 % if node is vulnerable or not 
                 vN=[vN; {node  data{i,1}{1,2} vulnerable}];
            end
        end
    end
    
end
        